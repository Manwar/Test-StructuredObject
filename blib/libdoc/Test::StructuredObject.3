.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::StructuredObject 3"
.TH Test::StructuredObject 3 "2013-02-05" "perl v5.17.9" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::StructuredObject \- Use a structured execution\-graph to create a test object which runs your tests smartly.
.SH "VERSION"
.IX Header "VERSION"
version 0.01000010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test::More;
\&    use Test::StructuredObject;
\&
\&    my $testsuite = testsuite(
\&        test { use_ok(\*(AqFoo\*(Aq); },
\&        test { is( Foo\->value, 7, \*(AqMagic value\*(Aq },
\&        step { note "This is a step!"; }
\&        testgroup( \*(AqThis is a subtest\*(Aq => (
\&            test { ok( 1, \*(Aqsome inner test\*(Aq ) },
\&            test { ok( 1, \*(Aqanother inner test\*(Aq ) },
\&        ))
\&    );
\&
\&    # Employs Test::More\*(Aqs very recent \*(Aqsubtest\*(Aq call internally to do subtesting.
\&
\&    $testsuite\->run();
\&
\&    # Flattens the subtests into a linear fashion instead, decorated with \*(Aqnote\*(Aq\*(Aqs  for older Test::More\*(Aqs
\&    $testsuite\->linearize\->run();
\&
\&    # Prints a simplistic (non\-reversable) serialisation of the testsuite or diagnostic purposes.
\&    print $testsuite\->to_s;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This technique has various perks:
.IP "1. No need to count tests manually" 4
.IX Item "1. No need to count tests manually"
.PD 0
.IP "2. Tests are still counted internally:" 4
.IX Item "2. Tests are still counted internally:"
.PD
Test harness can report tests that failed to run.
.IP "3. Tests are collected in a sort of state-graph of sorts:" 4
.IX Item "3. Tests are collected in a sort of state-graph of sorts:"
This is almost A.S.T. like in nature, which permits various run-time permutations of the graph for
different results.
.ie n .IP "4. Every ""test { }"" closure is executed in an ""eval { }"":" 4
.el .IP "4. Every \f(CWtest { }\fR closure is executed in an \f(CWeval { }\fR:" 4
.IX Item "4. Every test { } closure is executed in an eval { }:"
This makes subsequent tests not get skipped if one dies.
.IP "5. Internal storage of many simple sub-calls:" 4
.IX Item "5. Internal storage of many simple sub-calls:"
This allows reasonably good \f(CW\*(C`Deparse\*(C'\fR introspection, so if need be, the entire
execution tree can easily be rewritten to be completely Test::StructuredObject free.
.PP
However, it has various downsides, which for most things appear reasonable to me:
.IP "1. Due to lots of closures:" 4
.IX Item "1. Due to lots of closures:"
Due to this, the only present variable transience is achieved via external lexical variables.
.Sp
A good solution to this I've found is just pre-declare all your needed variables and pretend
they're like \s-1CPU\s0 registers =).
.ie n .IP "2. Closures break ""\->import"" in many cases:" 4
.el .IP "2. Closures break \f(CW\->import\fR in many cases:" 4
.IX Item "2. Closures break ->import in many cases:"
Due to closure techniques, code that relies on \f(CW\*(C`\->import\*(C'\fR to do lexical scope mangling may not work.
.Sp
That is pesky for various reasons, but on average its not a problem, as it is, existing Test
files need that \f(CW\*(C`BEGIN{  use_ok }\*(C'\fR stuff to get around this issue anyway.
.Sp
But basically, all you need to do is 'use' in your file scope in these cases, or use Fully Qualified sub
names instead.
.Sp
If neither of these solutions appeals to you, \s-1YOU DON\s0'T \s-1HAVE TO USE THIS MODULE\s0!.
.SH "EXPORTS"
.IX Header "EXPORTS"
This module exports the following symbols by default using \f(CW\*(C`Sub::Exporter\*(C'\fR , and as such,
you can tweak and use export tunings as supported by that module.
.ie n .IP """test""" 4
.el .IP "\f(CWtest\fR" 4
.IX Item "test"
.Vb 1
\&    test {  test_pragma }
.Ve
.Sp
This method creates a \f(CW\*(C`Test\*(C'\fR object containing the given code.
Code is run at run-time when called on the objects \f(CW\*(C`\->run\*(C'\fR method.
The code is run in an \f(CW\*(C`eval\*(C'\fR container and as such will not die. Deaths called inside the \f(CW\*(C`eval\*(C'\fR will
merely be downgraded to warnings and passed to \f(CW\*(C`carp\*(C'\fR. See
the run documentation for details.
.Sp
This object type is recognised by containing types, and presence of such types increments the relevant
number of planned tests at various levels.
.ie n .IP """step""" 4
.el .IP "\f(CWstep\fR" 4
.IX Item "step"
.Vb 1
\&    step { code_step }
.Ve
.Sp
This method is virtually identical to the \f(CW\*(C`test\*(C'\fR method except that the returned object is
instead an \f(CW\*(C`NonTest\*(C'\fR, and as such, containing types won't increment the
test count when it is seen. It is advised you use this method for doing things that prepare data for the
test, but don't actually do any testing. Additionally, it is advised to keep a 1\-step\-per\-statement ratio,
because I feel this may pay off one day when I get proper tree processing =).
.ie n .IP """testsuite""" 4
.el .IP "\f(CWtestsuite\fR" 4
.IX Item "testsuite"
.Vb 1
\&    testsuite( Test|NonTest|SubTest, ....   )
.Ve
.Sp
This method is just a sugar syntax to create a \f(CW\*(C`TestSuite\*(C'\fR instance.
Its parameter list comprises of a list of either \f(CW\*(C`Test\*(C'\fR,
\&\f(CW\*(C`NonTest\*(C'\fR or \f(CW\*(C`SubTest\*(C'\fR instances.
.Sp
As a side perk, if you use the following notation instead:
.Sp
.Vb 1
\&    testsuite( name => (   Test | NonTest | SubTest, ...  ) )
.Ve
.Sp
It will behave the same as \*(L"testgroup\*(R" does.
.ie n .IP """testgroup""" 4
.el .IP "\f(CWtestgroup\fR" 4
.IX Item "testgroup"
.Vb 1
\&    testgroup( name => ( Test | NonTest | SubTest , ... ) )
.Ve
.Sp
This method creates a structural subgroup of tests (\f(CW\*(C`SubTest\*(C'\fR) with the given name.
When the top \f(CW\*(C`TestSuite\*(C'\fR is executed in normal conditions, this runs each test of the \f(CW\*(C`subtest\*(C'\fR under
\&\f(CW\*(C`Test::More\*(C'\fR's '\f(CW\*(C`subtest\*(C'\fR' function creating pretty indented test \s-1TAP\s0 output.
.Sp
This object, when linearised with \f(CW\*(C`\->linearize\*(C'\fR instead injects 'note' subs before and after all its
children tests in the output linear test run, particularly useful for older Test::More instances.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kent Fredric <kentnl@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Kent Fredric <kentnl@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
